Doubly Linked List (DLL) is a linear data structure consisting of nodes, where each node contains:
     ¡.Data: The value stored in the node (e.g., an integer)
     ¡¡.Previous Pointer: A reference to the previous node in the sequence.
      ¡¡¡.Next Pointer: A reference to the next node in the sequence.
Unlike a Singly Linked List (which only links to the next node), a DLL allows bidirectional traversal (forward and backward).
The list has:
     a.A head pointer to the first node.
     b.A tail pointer to the last node (optional, for efficiency).
     c.An empty list has head = NULL.
         Key Characteristics of DDL
A.Dynamic Size: Nodes can be added or removed at runtime.
B.Bidirectional Traversal: Access nodes in both directions using prev and next pointers.
C.Memory Overhead: Requires extra memory for the prev pointer compared to a singly linked list.
D.Applications: Used in scenarios requiring frequent insertions/deletions or backward traversal, 
e.g., browser history, undo/redo functionality.
     Operations on a Doubly Linked List
1.Add a Node at the Front:Insert a new node as the first node (new head).
step:i.Create a new node with the given data.
     ¡¡.Set its next to the current head and prev to NULL.
      ¡¡¡.Update head to the new node.
       ¡¡¡¡.Update head to the new node.
Time Complexity: O(1) (constant time, no traversal needed).
Space Complexity: O(1) (single node allocation).
2.Traversal:Visit and process (e.g., print) all nodes in the list.
 step:1.Start at head.
      2.While the current node is not NULL, process its data and move to next.
      Can also traverse backward from tail using prev.
Time Complexity: O(n) (n = number of nodes).
Space Complexity: O(1) (no extra space beyond a pointer).
3.Insertion:Add a new node as the last node (new tail).
          step:a.Create a new node with the given data.
              b.If the list is empty, set head and tail to the new node.
              c.Otherwise, set the current tail’s next to the new node, and the new node’s prev to tail. 
               d.Update tail to the new node.
Time Complexity: O(1) (if tail is maintained).
Space Complexity: O(1).
At a Given Position (pos): Insert a node at position pos (1-based indexing, where 1 is the head).
        step:1.If pos is invalid (< 1 or > n+1), report an error.
            2. pos == 1, insert at the beginning.
            3.If pos == n+1, insert at the end. 
             4.Otherwise:Traverse to the node at position pos (or pos-1 for easier pointer updates).
Create a new node and adjust pointers:
New node’s next = current node.
New node’s prev = current node’s prev.
Update prev and next pointers of adjacent nodes.
Time Complexity: O(n) (due to traversal to position).
Space Complexity: O(1).
4.Deletion:At the Beginning: Remove the head node.
         step:A.If the list is empty, do nothing.
               B.Set head to head->next.
               C.  If the new head exists, set its prev to NULL. 
               D.Free the old head’s memory. 
               E.If the list becomes empty, update tail to NULL.
Time Complexity: O(1).
Space Complexity: O(1).
At the End: Remove the tail node.
           step:1.If the list is empty, do nothing.
                 2.Set tail to tail->prev.Set tail->next to NULL. 
                  3.Free the old tail’s memory. 
                  4If the list becomes empty, update head to NULL.
Time Complexity: O(1) (if tail is maintained).
Space Complexity: O(1).
At a Given Position (pos): Remove the node at position pos.
          step:a.If pos is invalid, report an error.
              b.If pos == 1, delete at the beginning.
               c.If pos == n, delete at the end.
Otherwise:Traverse to the node at pos.
Update the next pointer of the previous node and the prev pointer of the next node.
Free the target node’s memory.
Time Complexity: O(n) (due to traversal).
Space Complexity: O(1).

